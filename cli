#!/usr/bin/python
# -*- coding:utf-8 -*-
__author__ = 'xiaozhang'

import atexit
from signal import SIGTERM
import sys
import os
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
import urllib
if PY2:
    import urllib2 as urllib2
    from urlparse import urlparse
if PY3:
    import urllib.request as urllib2
    from urllib.parse import urlparse
    urllib.urlencode=urllib.parse.urlencode



import subprocess
import time
import datetime
import re
import logging
import hashlib

import tempfile
import threading
import getopt
from logging.handlers import RotatingFileHandler
import json
import random
import platform
import socket

import uuid
import inspect
import getpass


pidfile="/var/cli.pid"
server_url="http://172.17.140.116:8005"
# server_url="http://10.3.155.104:8005"

configfile='/etc/cli'
default_module='cli'
bin_name='cli'
client_filename='/bin/%s' % bin_name
script_path= tempfile.gettempdir()+ os.path.sep+'script'
global_debug=False
PLATFORM=platform.system().lower()
PYTHON_PATH='/usr/bin/python'



def init_log():
    user=getpass.getuser()
    client_log_filename='/var/log/cli.log'
    try:
        _p=os.popen('which python').read().strip()
        if _p!='' and len(_p)>0:
            PYTHON_PATH=_p
    except Exception as er:
        pass

    log_dir= os.path.dirname(client_log_filename)
    if not os.path.exists(log_dir):
        os.mkdir(log_dir)
    # if user=='root':
    #     os.chmod(log_dir,0666)
    log_fmt_str='%(asctime)-25s %(module)s:%(lineno)d  %(levelname)-8s %(message)s'
    if PY2:
        logging.basicConfig(level=logging.DEBUG,
                format=log_fmt_str,
                filemode='a+')
    if PY3:
        log_fmt_str='%(asctime)s %(module)s:%(lineno)d  %(levelname)s %(message)s'
        logging.basicConfig(level=logging.DEBUG,
                format=log_fmt_str)
    logger = logging.getLogger('CLI')
    file_handler=RotatingFileHandler(filename=client_log_filename,maxBytes=100 * 1024 * 1024, backupCount=3)
    formatter= logging.Formatter(log_fmt_str)
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter )
    logger.addHandler(file_handler)
    if user=='root' and PLATFORM!='windows':
        try:
            if len(os.popen('command -v chattr').read())>1:
                os.popen('chattr -a %s'%(client_log_filename)).read()
                os.chmod(client_log_filename,777)
                os.popen('chattr +a %s'%(client_log_filename)).read()
        except Exception as er:
            pass
    return logger

logger=init_log()



class CertificateError(ValueError):
    pass
try:
    import ssl
except ImportError:
    ssl = None
    import warnings
    msg = ("Can't import ssl. HTTPS won't work."
           "Run `pip install ssl` if Python < 2.6")
    try:
        ImportWarning
    except NameError:
        warnings.warn(msg)
    else:
        warnings.warn(msg, ImportWarning)
else:
    try:
        from http import client
    except ImportError:
        import httplib as client
    import re
    try:
        import urllib2 as request
    except ImportError:
        from urllib import request
    class HTTPSConnection(client.HTTPSConnection):
        def __init__(self, host, **kwargs):
            self.ca_certs = kwargs.pop('ca_certs', None)
            self.checker = kwargs.pop('checker', None)
            self.timeout = kwargs.get('timeout', socket.getdefaulttimeout())
            client.HTTPSConnection.__init__(self, host, **kwargs)


        def connect(self):
            args = [(self.host, self.port), self.timeout,]
            if hasattr(self, 'source_address'):
                args.append(self.source_address)
            sock = socket.create_connection(*args)
            if getattr(self, '_tunnel_host', None):
                self.sock = sock
                self._tunnel()
            kwargs = {}
            if self.ca_certs is not None:
                kwargs.update(
                    cert_reqs=ssl.CERT_REQUIRED,
                    ca_certs=self.ca_certs)
            self.sock = ssl.wrap_socket(sock,
                                        keyfile=self.key_file,
                                        certfile=self.cert_file,
                                        **kwargs)
            if self.checker is not None:
                try:
                    self.checker(self.sock.getpeercert(), self.host)
                except CertificateError:
                    self.sock.shutdown(socket.SHUT_RDWR)
                    self.sock.close()
                    raise
    class HTTPSHandler(request.HTTPSHandler):
        def __init__(self, key_file=None, cert_file=None, ca_certs=None,
                     checker=None):
            request.HTTPSHandler.__init__(self)
            self.key_file = key_file
            self.cert_file = cert_file
            self.ca_certs = ca_certs
            self.checker = self.match_hostname
        def _dnsname_to_pat(self,dn):
            pats = []
            for frag in dn.split(r'.'):
                if frag == '*':
                    pats.append('[^.]+')
                else:
                    frag = re.escape(frag)
                    pats.append(frag.replace(r'\*', '[^.]*'))
            return re.compile(r'\A' + r'\.'.join(pats) + r'\Z', re.IGNORECASE)
        def match_hostname(self,cert, hostname):
            return
            if not cert:
                raise ValueError("empty or no certificate")
            dnsnames = []
            san = cert.get('subjectAltName', ())
            for key, value in san:
                if key == 'DNS':
                    if self._dnsname_to_pat(value).match(hostname):
                        return
                    dnsnames.append(value)
            if not dnsnames:
                for sub in cert.get('subject', ()):
                    for key, value in sub:
                        if key == 'commonName':
                            if self._dnsname_to_pat(value).match(hostname):
                                return
                            dnsnames.append(value)

            if len(dnsnames) > 1:
                raise CertificateError("hostname %r "
                    "doesn't match either of %s"
                    % (hostname, ', '.join(map(repr, dnsnames))))
            elif len(dnsnames) == 1:
                raise CertificateError("hostname %r "
                    "doesn't match %r"
                    % (hostname, dnsnames[0]))
            else:
                raise CertificateError("no appropriate commonName or "
                    "subjectAltName fields were found")
        def https_open(self, req):
            return self.do_open(self.getConnection, req)
        def getConnection(self, host, **kwargs):
            d = dict(cert_file=self.cert_file,
                     key_file=self.key_file,
                     ca_certs=self.ca_certs,
                     checker=self.checker)
            d.update(kwargs)
            return HTTPSConnection(host, **d)

class Daemon(object):
        def __init__(self, pidfile, stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
                self.stdin = stdin
                self.stdout = stdout
                self.stderr = stderr
                self.pidfile = pidfile
                self.salt=''
                self.pid=''
                self.shellstr=''

        def daemonize(self):
                try:
                        pid = os.fork()
                        if pid > 0:
                                # exit first parent
                                sys.exit(0)
                except OSError as  e:
                        sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
                        sys.exit(1)
                os.chdir("/")
                os.setsid()
                os.umask(0)

                # do second fork
                try:
                        pid = os.fork()
                        if pid > 0:
                                # exit from second parent
                                sys.exit(0)
                except OSError as  e:
                        sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
                        sys.exit(1)

                # redirect standard file descriptors
                sys.stdout.flush()
                sys.stderr.flush()
                si = open(self.stdin, 'r')
                so = open(self.stdout, 'a+')
                se = open(self.stderr, 'a+')
                os.dup2(si.fileno(), sys.stdin.fileno())
                os.dup2(so.fileno(), sys.stdout.fileno())
                os.dup2(se.fileno(), sys.stderr.fileno())

                # write pidfile
                atexit.register(self.delpid)
                pid = str(os.getpid())
                self.pid=pid
                open(self.pidfile,'w+').write("%s\n" % pid)

        def delpid(self):
                os.remove(self.pidfile)

        def start(self):
                try:
                        pf = open(self.pidfile,'r')
                        pid = int(pf.read().strip())
                        pf.close()
                except IOError:
                        pid = None
                if pid:
                        message = "pidfile %s already exist. Daemon already running?\n"
                        sys.stderr.write(message % self.pidfile)
                        sys.exit(1)
                self.daemonize()
                self.run()

        def kill(self):
            try:
                self.daemonize()
                kill='''
                  ps aux|grep -v grep|grep -v -w '%s'|grep python|grep -w 'cli daemon'|awk '{print $2}'|xargs -n 1 kill -9
                  ''' % (self.pid)
                if os.path.exists(self.pidfile):
                    os.remove(self.pidfile)
                ZbxCommand(kill,is_log=False).run()
            except Exception as er:
                pass

        def stop(self):
                try:
                        pf = open(self.pidfile,'r')
                        pid = int(pf.read().strip())
                        pf.close()
                except IOError:
                        pid = None
                self.kill()
                if not pid:
                        message = "pidfile %s does not exist. Daemon not running?\n"
                        sys.stderr.write(message % self.pidfile)
                        return # not an error in a restart

                # Try killing the daemon process
                try:
                        while 1:
                                os.kill(pid, SIGTERM)
                                time.sleep(0.1)
                except OSError as  err:
                        err = str(err)
                        if err.find("No such process") > 0:
                                if os.path.exists(self.pidfile):
                                        os.remove(self.pidfile)
                        else:
                                print(str(err))
                                sys.exit(1)
        def restart(self):
                self.stop()
                self.start()


class ZbxCommand(object):
    def __init__(self, cmd,is_log=False):
        mc=re.match('^su\s+[\'"a-zA-z09]+?\s+\-c',cmd)
        if PLATFORM=='windows' and mc!=None:
            cmd=cmd.replace(mc.group(0),'')
            cmd=cmd.strip()
            cmd=re.sub('^\"|\"$','',cmd)
        self.cmd = cmd
        self.process = None
        self.is_log=is_log
        self.uuid=str(datetime.datetime.now()).replace(' ','').replace(':','').replace('-','').replace('.','')
        self.result=open(tempfile.gettempdir()+ os.path.sep +self.uuid,'a+')


    def run(self, timeout=30):
        def target():
            if self.is_log:
                logger.info(self.cmd)
            self.process = subprocess.Popen(self.cmd, shell=True,stdout=self.result,stderr=self.result)
            self.process.communicate()
        thread = threading.Thread(target=target)
        thread.start()
        thread.join(timeout)
        if thread.is_alive():
            logger.warn(self.cmd)
            self.process.terminate()
            thread.join()
            util=ZbxCommon()
            util.url_fetch(server_url+'/slowlog',{'param':{ 'cmd':self.cmd,'ip':util.get_one_ip()}})
            return "13800138000"
        result= open(tempfile.gettempdir()+ os.path.sep+self.uuid,'r').read()
        try:
            os.unlink(tempfile.gettempdir()+ os.path.sep+self.uuid)
        except Exception as er:
            pass
        return result


class ZbxCommon(object):
    def __init__(self):
        self.machine_id=''

    def urlencode(self,str):
        reprStr=repr(str).replace(r'\x','%')
        return reprStr[1:-1]

    def download(self,filename,directory,filepath):
        try:
            data={'file':filename,'dir':directory}
            data=urllib.urlencode(data)
            http_url='%s/%s/download?%s' % (server_url,default_module,data)
            conn = urllib2.urlopen(http_url)
            f = open(filepath,'wb')
            f.write(conn.read())
            f.close()
        except Exception as e:
            logger.error(e)
            print(e)

    def upload(self,url,filepath,directory):
        boundary = '----------%s' % hex(int(time.time() * 1000))
        data = []
        data.append('--%s' % boundary)
        fr=open(filepath,'rb')
        filename=os.path.basename(filepath)
        data.append('Content-Disposition: form-data; name="%s"\r\n' % 'filename')
        data.append(filename)
        data.append('--%s' % boundary)
        data.append('Content-Disposition: form-data; name="%s"\r\n' % 'dir')
        data.append(directory)
        data.append('--%s' % boundary)
        data.append('Content-Disposition: form-data; name="%s"; filename="%s"' % ('file',filename))
        data.append('Content-Type: %s\r\n' % 'image/png')
        data.append(fr.read())
        fr.close()
        data.append('--%s--\r\n' % boundary)

        http_body='\r\n'.join(data)
        try:
            req=urllib2.Request(url, data=http_body)
            req.add_header('Content-Type', 'multipart/form-data; boundary=%s' % boundary)
            req.add_header('User-Agent','Mozilla/5.0')
            req.add_header('Referer','http://remotserver.com/')
            resp = urllib2.urlopen(req, timeout=5)
            qrcont=resp.read()
            print(qrcont)
        except Exception as e:
            logger.error(e)
            print(e)
            print('http error')

    def url_fetch_witherr(self,url,data=None,timeout=30,httpCmd=''):
        return self._url_fetch(url,data,timeout,httpCmd)

    def url_fetch(self,url,data=None,timeout=30,httpCmd='',debug=False):
        try:
            return self._url_fetch(url,data,timeout,httpCmd,debug)
        except Exception as er:
            print(er)
            return ''


    def _url_fetch(self,url,data=None,timeout=30,httpCmd='',debug=False):
        html=''
        handle=None
        # print(url)
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        key=''
        if os.path.isfile(fn):
            with open(fn) as f:
                key=f.read().strip()
        try:
            headers = {
                'User-Agent':'CLI agent(1.0)',
                'auth-uuid':key
            }
            if data!=None:
                data=urllib.urlencode(data)
                if PY3:
                    data=data.encode('utf-8','ignore')
                # print(data)

            req = urllib2.Request(
                url =url,
                headers = headers,
                data=data
            )
            if httpCmd != "":
                req.get_method = lambda: httpCmd

            handle=urllib2.urlopen(req,timeout=timeout)



            html=handle.read()
            cm=r'<meta[^>]*charset=[\'\"]*?([a-z0-8\-]+)[\'\"]?[^>]*?>'
            if PY3:
                cm=cm.encode('utf-8','ignore')
            charset=re.compile(cm,re.IGNORECASE).findall(html)
            if len(charset) >0:
                if charset[0]=='gb2312':
                    charset[0]='gbk'
                html=unicode(html,charset[0])
            if PY3:
                return html.decode('utf-8','ignore')
        except Exception as e:
            raise Exception(e)
        finally:
            if handle!=None and handle.fp!=None:
                try:
                    handle.fp.close()
                except Exception as er:
                    pass

        return html

    def cmdline_args(self,s):
        import re
        l= re.findall(r"'[\s\S]*[\']?'|\"[\s\S]*[\"]?\"",s,re.IGNORECASE|re.MULTILINE)
        for i,v in enumerate(l):
            s=s.replace(v,'{'+str(i)+'}')
        p=re.split(r'\s+',s)
        ret=[]
        for a in p:
            if re.match(r'\{\d+\}',a):
                a=l[int(re.sub(r'^{|}$','',a))]
            ret.append(a)
        return ret
    def getopt(self,inputs):
        def ptype(input):
            if input == "":
                return (0,"")
            if "-" == input[0] and len(input) == 2:
                return (1,input[1])
            if "--" == input[:2] and len(input) >= 4:
                return (2,input[2:])
            return (0,"")
        def istype(input):
            if len(input) <= 0:
                return 0
            if "-" == input[0]:
                return 1
            return 0
        ret = {}
        ret['__ctrl__']=''
        ret['__func__']=''
        u = 0
        ucount = len(inputs)
        icount = 0
        ls = []
        if ucount >= 1:
            while 1:
                if u >= ucount:
                    break
                if istype(inputs[u]) == 1:
                    break

                ls.append(inputs[u])
                u += 1

            inputs = inputs[u:]
            icount = len(inputs)

        if icount >= 1:
            i = 0
            state = 0
            while 1:
                t,name = ptype(inputs[i])
                for c in range(1):
                    if t == 0 :
                        i += 1
                        break
                    if i+1 < icount:
                        tt,tname = ptype(inputs[i+1])
                        if tt != 0:
                            ret[name] = ""
                            i += 1
                            break
                        ret[name] = inputs[i+1]
                        i += 2
                        break
                    ret[name] = ""
                    i += 1
                    break
                if i >= icount:
                    break
        if len(ls)==2:
            ret['__ctrl__']=ls[0]
            ret['__func__']=ls[1]
        elif len(ls)==1:
            ret['__ctrl__']=''
            ret['__func__']=ls[0]
        return (ret)

    def parse_argv(self,argv):
        data={}
        long_args=[]
        short_args=[]
        for v in argv:
            if v.startswith('--'):
                long_args.append(v.replace('--','')+"=")
            elif v.startswith('-'):
                short_args.append(v.replace('-',''))
        opts= getopt.getopt(argv,":".join(short_args)+":",long_args)
        for opt in opts[0]:
            data[opt[0].replace('-','')]=opt[1]
        if len(data)>0:
            return data
        else:
            return argv

    def md5(self, src):
        m2 = hashlib.md5()
        if PY3:
            src=str(src).encode('utf-8','ignore')
        m2.update(src)
        return m2.hexdigest()

    def now_datetime(self):
        now_datetime = time.strftime('_%Y-%m-%d_%H_%M_%S', time.localtime(time.time()))
        return now_datetime

    def execute(self,cmd):
        try:
            return ZbxCommand(cmd).run()
            # return os.popen(cmd).read()
        except Exception as err:
            logger.error(err)
            return ""


    def get_all_ip_list(self):
        if platform.system().lower()=='windows':
            name,xx,ips=socket.gethostbyname_ex(socket.gethostname())
            return ips
        else:
            cmdline = "ip a | egrep \"^\s*inet.*\" | grep -v inet6 | awk '{print $2}' | awk -v FS='/' '{print $1}'"
            ret = self.execute(cmdline)
            lip=re.split(r'\n',ret)
            ips=[]
            for ip in lip:
                if str(ip).strip ()!='':
                  ips.append(ip.strip())
            return ips


    def get_uuid(self):
        return str(uuid.uuid4())


    def get_one_ip(self):
        #ret = [x for x in self.get_all_ip_list() if x.startswith('10') or x.startswith('172') or x.startswith('192')]
        ret = [x for x in self.get_all_ip_list() if x.startswith('10.') or  x.startswith('172.') or  x.startswith('192.') ]
        if len(ret)>1:
            return ret[0]
        return ''.join(ret)

    def get_product_uuid(self):
        if self.machine_id!='' and len(self.machine_id)==36:
            return self.machine_id
        product_uuid=''
        # if os.path.isfile('/sys/devices/virtual/dmi/id/product_uuid'):
        #     product_uuid=self.execute('cat /sys/devices/virtual/dmi/id/product_uuid').strip()
        if product_uuid=="":
            uuid_file='/etc/machine_id'
            if not os.path.exists(uuid_file):
                product_uuid=self.get_uuid()
                with open(uuid_file,'w') as file:
                    file.write(product_uuid)
            else:
                with open(uuid_file,'r') as file:
                    product_uuid=file.read()
        self.machine_id=product_uuid
        return product_uuid


    def get_hostname(self):
        os_name = os.name
        host_name = ""
        try:
            if os_name == 'nt':
                host_name = os.getenv('computername')
            elif os_name == 'posix':
                host = os.popen('hostname')
                try:
                    host_name = host.read().strip()
                except:
                    host_name=''
                finally:
                    host.close()
            if host_name.strip()=='':
                host_name= socket.gethostbyname()
        except Exception as er:
            logger.error(er)
            return ""
        return host_name.strip()


    def exec_filename(self):
        path = os.path.realpath(sys.path[0])
        if os.path.isfile(path):
            path = os.path.dirname(path)
            return os.path.abspath(path)+ os.path.sep+__file__
        else:
            caller_file = inspect.stack()[1][1]
            return os.path.abspath(os.path.dirname(caller_file))+ os.path.sep+__file__



    def tuple2list(self,*args):
        print(args)
        l=[]
        for i in args:
            l.append(i)
        return l

    def command_args(self,args):
        if isinstance(args,list) or isinstance(args,tuple):
            return '"%s"' % '" "'.join(args)
        else:
            return str(args)

class ZbxCli():

    def __init__(self,default_module):
        self.entry=server_url+'/'+default_module+"/%s"
        self.util=ZbxCommon()
        # self.etcd_prefix=etcd_prefix


    def download(self,args):
        argv= self.util.parse_argv(args)
        if isinstance(argv,list):
            argv={}
        if 'f' in argv.keys():
            f=argv['f']
        else:
            return '(error) -f(filename) require'
        if 'd' not in argv:
            d='/'
            try:
                d=getpass.getuser()
            except Exception as er:
                pass
            argv['d']=d
        if 'o' not in argv:
            argv['o']=argv['f']
        self.util.download(argv['f'],argv['d'],argv['o'])

    def upload(self,args):
        argv= self.util.parse_argv(args)
        if isinstance(argv,list):
            argv={}
        if 'f' in argv.keys():
            f=argv['f']
        else:
            return '(error) -f(filename) require'
        if 'd' not in argv:
            d='/'
            try:
                d=getpass.getuser()
            except Exception as er:
                pass
            argv['d']=d
        self.util.upload(self.entry%"upload", argv['f'],argv['d'])

    def help(self,args):
        ret=self.util.url_fetch(self.entry%'help')
        print(ret)

    def upgrade(self,args):
        fn=self.util.exec_filename()
        content=self.util.url_fetch(self.entry%'upgrade')
        if content!='':
            open('/tmp/cli','w').write(content)
            os.system('chmod +x /tmp/cli')
            os.system('mv -f /tmp/cli %s' %(client_filename))
            print('success')
        else:
            print('fail')
    def adddoc(self,args):
        argv=self.util.getopt(args)
        if 'f' in argv:
            argv['d']=open(argv['f'],'r').read()

        ret=self.util.url_fetch(self.entry%'adddoc',{'param':json.dumps(argv)})
        print(ret)

    def daemon(self,argv):
        daemon = ZbxDaemon(pidfile)
        setattr(daemon,'zbxcli',self)
        key_file='/etc/cli/etcd-worker-key.pem'
        cert_file='/etc/cli/etcd-worker.pem'
        if os.path.exists(key_file) and os.path.exists(cert_file):
            opener=urllib2.build_opener(HTTPSHandler(cert_file=cert_file,key_file=key_file))
            urllib2.install_opener(opener)
        data= self.util.getopt(sys.argv[1:])
        opt = data.get('s')
        if 'start' == opt:
            print("cli daemon start")
            daemon.start()
        elif 'stop' == opt:
            print("cli daemon stop")
            daemon.stop()
        elif 'restart' == opt:
            print("cli daemon restart")
            daemon.restart()
        elif 'debug' == opt:
            global_debug=True
            daemon.run()
        elif 'kill' == opt:
            daemon.kill()
        elif 'install'==  opt:
            pass
        else:
            print("usage: cli deamon -s start|stop|restart")
            sys.exit(2)
        sys.exit(0)

    def logout(self,argv):
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        if os.path.isfile(fn):
            with open(fn,"w") as f:
                f.write('')
    def register(self,argv):
        data= self.util.getopt(sys.argv[1:])
        if 'u' not in data:
            data['u']=raw_input('please input username: ')
        if 'p' not in data:
            data['p']=getpass.getpass('please input password: ')
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(data)})
        print(ret)

    def login(self,argv):
        data= self.util.getopt(sys.argv[1:])
        if 'u' not in data:
            data['u']=raw_input('please input username: ')
        if 'p' not in data:
            data['p']=getpass.getpass('please input password: ')
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(data)})
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        # if os.path.isfile(fn):
        with open(fn,"w") as f:
            f.write(ret)
            if len(ret)==36:
                print('success')
                return
            else:
                print(ret)
                return
        print(ret)

    def rexec(self,argv):
        data= self.util.getopt(sys.argv[1:])
        if 'u' not in data:
            data['u']=raw_input('please input username: ')
        if 'p' not in data:
            data['p']=getpass.getpass('please input password: ')
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(data)})
        print(ret)


    def config(self,argv):
        conf='''
pidfile=/var/zbxcli.pid
server_url=http://127.0.0.1:8005
'''
        with open(configfile,'w') as f:
            f.write(conf)

    def default(self,module,action,args):
        #argv= self.util.parse_argv(args)
        argv=self.util.getopt(args)
        if isinstance(argv,list):
            argv={}
        if isinstance(argv,dict):
            if not 's' in argv:
                argv['s']=self.util.get_hostname()
            if not 'i' in argv:
                argv['i']=self.util.get_one_ip()
            #if not 'g' in argv:
            #    argv['g']="Discovered hosts"
            #if not 't' in argv:
            #    argv['t']="Meizu-System"
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(argv)},timeout=3*60)
        if ret.strip()!='':
            try:
                ret=json.dumps(json.loads(ret),sort_keys=True,indent=2)
            except Exception as er:
                pass
        print(ret)
        return ret

    def request(self,args):
        argv=self.util.getopt(args)
        url=''
        if not 'url' in argv.keys():
            print('--url(url) url is request')
            return
        else:
            url=argv['url']
        keys=['__func__','__ctrl__','url']
        for key in keys:
            if key in argv.keys():
                del argv[key]
        data=argv
        method="GET"
        if len(data)>0:
            method="POST"
        result=self.util._url_fetch(url,data,httpCmd=method)
        print(result)
        return result

    def md5(self,argv):
        data= self.util.getopt(sys.argv[1:])
        if not 's' in data and not 'f' in data:
            print('-s(string) is required or -f(file name) is required')
            return
        if 'f' in data:
            if os.path.exists(data['f']):
                with open(data['f'],'rb') as fp:
                    data['s']=fp.read()
            else:
                print('-f(filename) is not found ')
                return
        print(self.util.md5(data['s']))

    def uuid(self,argv):
        print(self.util.get_uuid())

    def machine_id(self,argv):
        print(self.util.get_product_uuid())

    def eval(self,argv):
        data= self.util.getopt(sys.argv[1:])
        if 's' in data:
            print(eval(data['s']))

    def remote_server(self,module,action,argv):
        if isinstance(argv,dict):
            if not 's' in argv:
                argv['s']=self.util.get_hostname()
            if not 'i' in argv:
                argv['i']=self.util.get_one_ip()
            #if not 'g' in argv:
            #    argv['g']="Discovered hosts"
            #if not 't' in argv:
            #    argv['t']="Meizu-System"
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(argv)})
        return ret




    def shell(self,args):
        if len(args)<1:
            print('ERROR: param is not enough')
            sys.exit(0)

        #path=tempfile.gettempdir()+os.sep+'zbxcli';
        filename=''
        dir='shell'
        # argv= self.util.parse_argv(args)
        argv= self.util.getopt(args)

        if 'f' in argv.keys():
            filename=argv['f']
        else:
            return '(error) -f(filename) require'
        if 'd' in argv.keys():
            dir=argv['d']
        else:
            dir='/'
            try:
                dir=getpass.getuser()
            except Exception as er:
                pass
        path=script_path+os.path.sep+dir
        # print(path)
        if not os.path.exists(path):
            self.util.execute('mkdir -p %s'%path)


        fn=path+os.path.sep+filename
        src=''
        is_python=False
        result=-1
        if not os.path.exists(fn) or os.stat(fn).st_mtime<(time.time()-10*60) or 'u' in argv.keys():
            src=self.util.url_fetch(self.entry%'shell',{ 'file':filename, 'param': json.dumps(args[1:]),'dir':dir},timeout=60*60)
        if src!='':
            open(fn,'w').write(src)
        else:
            src=open(fn,'r').read()

        lines=re.split(r'\n',src)
        for line in lines:
            if line.strip()!='':
                break;
        if line.find('python')>0:
                is_python=True
        argstr=''
        if 'a' in argv.keys():
            argstr=argv['a']
        shell_argv=self.util.cmdline_args(argstr)
        if is_python:
            cmd=ZbxCommand('%s %s %s'% ( PYTHON_PATH, fn, " ".join(shell_argv)))
            result=cmd.run(60*60*24)
        elif line.find('bash')>0:
            cmd=ZbxCommand('/bin/bash %s %s'% (fn," ".join(shell_argv)))
            result=cmd.run(60*60*24)
        else:
            os.system("chmod +x %s" % (fn))
            cmd=ZbxCommand('%s %s'% (fn," ".join(shell_argv)))
            result=cmd.run(60*60*24)
        print(result)

class ZbxDaemon(Daemon):




    def __getattr__(self,attr):
        if hasattr(self,'zbxcli'):
            if hasattr(self.zbxcli,attr):
                return getattr(self.zbxcli,attr)
        return None

    def get_etcd(self):
        try:
            now = time.time()
            if now - self.update_time > 600:
                print("=== get etcd")
                # self.etcd_conf =  json.loads(self.remote_server('cli','getetcd',{}) )
                # print(self.etcd_conf)
                # self.etcd_list=self.etcd_conf['server']
                # self.etcd_prefix=self.etcd_conf['prefix']
                if not isinstance(self.etcd_list,list):
                    raise Exception("get etcd list error")
                for host in self.etcd_list:
                    print(self.util.url_fetch_witherr("%s%s/heartbeat" % (host,self.etcd_prefix) ,data={'ttl':60,'value':'heartbeat'},httpCmd = 'PUT' ))
                    print(self.util.url_fetch_witherr("%s%s/servers" % (host,self.etcd_prefix) ,data={'ttl':60,'value':'servers'},httpCmd = 'PUT' ))
                self.update_time = now
        except Exception as er:
            print(er)
            time.sleep(3)
            # return self.get_etcd()

    def status(self):
        try:
            filename='heartbeat'
            file_path=script_path+os.path.sep+'.'+filename
            if not os.path.exists(script_path):
                self.util.execute('mkdir -p %s'%script_path)
            if self.shellstr!='':
                open(file_path,'w').write(self.shellstr)
                os.chmod(file_path,777)
            cmd=ZbxCommand('%s %s'%(PYTHON_PATH,file_path),is_log=False)
            ret= cmd.run()
            return json.dumps(json.loads(ret))
        except Exception as er:
            if global_debug:
                print(er)
            return '{}'

    def heartbeat2server(self):
        try:
            ips=",".join(self.util.get_all_ip_list())
            # ret = self.zbxcli.default(default_module,'heartbeat',['--uuid',self.util.get_product_uuid(),
            #                                                       '--ips',ips,'--status', self.status(),'--platform',
            #                                                       platform.system().lower(),'--hostname',self.util.get_hostname() ])
            data={'uuid':self.util.get_product_uuid(),'ips':ips,'status':self.status(),
                  'platform':platform.system().lower(),'hostname':self.util.get_hostname() }
            ret=self.util.url_fetch(server_url+'/%s/%s'%(module,'heartbeat'),{'param':json.dumps(data)})
            objs= json.loads(ret)
            self.salt=objs['salt']
            self.etcd_conf=objs['etcd']
            if 'shell' in objs.keys():
                self.shellstr=objs['shell']

                # print(self.util.execute(self.shellstr))

            self.etcd_list=objs['etcd']['server']
            self.etcd_prefix=objs['etcd']['prefix']
            # print('salt',self.salt)
            logger.info("heartbeat2server OK")
        except Exception as er:
            print(er)
            time.sleep(3)
            logger.error('heartbeat2server'+str(er))

    def heartbeat(self):
        try:
            logger.info("=== heartbeat start")
            ip = self.util.get_product_uuid()
            for host in self.etcd_list:
                # print("heartbeat:  %s%s/heartbeat/%s" % (host,self.etcd_prefix,ip))
                ips=",".join(self.util.get_all_ip_list())
                try:
                    html=''
                    html = self.util.url_fetch_witherr("%s%s/heartbeat/%s" % (host,self.etcd_prefix,ip) ,data={'ttl':60*5,'value':ips},httpCmd = 'PUT' )
                    logger.info("heartbeat2etcd OK")
                    self.has_heartbeat_error=False
                except Exception as her:
                    pass
                if html != "":
                    break
            logger.info("=== heartbeata end")
        except Exception as er:

            time.sleep(3)
            print(er)
            if not self.has_heartbeat_error:
                logger.error('heartbeat error:'+str(er))
                self.has_heartbeat_error=True


    def watch_commmand(self):
        try:
            ip = self.util.get_product_uuid()
            # print("watch_commmand",ip,self.etcd_list)
            for host in self.etcd_list:
                content=''
                try:
                    content = self.util.url_fetch_witherr("%s%s/servers/%s?recursive=true" % (host,self.etcd_prefix,ip),timeout = 10 )
                except Exception as er:
                    time.sleep(3)
                    pass
                if content!='':
                    rjson=json.loads(content)
                    if rjson['node'].get('nodes'):
                        self.feedback_result(ip,host,content)
                        break
                self.util.url_fetch("%s%s/servers/%s?wait=true&recursive=true" % (host,self.etcd_prefix,ip),timeout = 20+ random.randint(1,10) )
                try:
                    content = self.util.url_fetch_witherr("%s%s/servers/%s?recursive=true" % (host,self.etcd_prefix,ip),timeout = 10 )
                except Exception as her:
                    # print(her)
                    pass
                # print("content   "+content)
                if content != "":
                    self.feedback_result(ip,host,content)
                    break
        except Exception as er:
            print(er)
            time.sleep(3)
            #logger.error('watch_commmand error:'+str(er))

    def delete_cmd(self,host,key):
        try:
            url = "%s%s?recursive=true" % (host,key)
            self.util.url_fetch(url,httpCmd= 'DELETE' )
        except Exception as er:
            print(er)

    def feedback_result(self,ip,host,content):
            try:
                # logger.info("process cmd")
                if content == "Not Found":
                    print("no found key")
                    return
                rjson = json.loads(content)
                if not rjson['node'].get('dir',False):
                    url = "%s/%s?recursive=true" % (host,rjson['node']['key'])
                    print("feedback_result"+ url)
                    self.util.url_fetch(url,httpCmd= 'DELETE' )
                    logger.info("publish is no dir")
                    return

                if not rjson['node'].get('nodes'):
                    # logger.info("no found command")
                    return

                logger.info("process cmd")
                key=''
                data={}
                for cNode in  rjson['node']['nodes']:
                    key = cNode['key']
                    createdIndex = cNode['createdIndex']
                    try:
                        # cNode=json.loads(cNode['value'])
                        cmd_uuid=str(cNode['value'])
                    except Exception as er:
                        logger.error('json error lost command : '+str(cNode))
                        self.delete_cmd(host,key)
                        print('json error lost command : '+str(er))
                        continue
                    # cmd=cNode['cmd']
                    # if PY2:
                    #     cmd = cmd.encode('utf-8')
                    # md5 = str(cNode['md5'])


                    argv={'uuid':cmd_uuid,'index':createdIndex}
                    ret=self.util.url_fetch_witherr(server_url+'/%s/%s'%(module,'get_cmd'),{'param':json.dumps(argv)},timeout=10)
                    if ret=='' or ret=='{}' or len(json.loads(ret))==0:
                        self.delete_cmd(host,key)
                        continue
                    data=json.loads(ret)
                    if PY2:
                        cmd = data['cmd'].encode('utf-8')
                    if PY3:
                        cmd=data['cmd']
                    md5 = str(data['md5'])


                    if 'timeout' in data.keys():
                        timeout = float(data['timeout'])
                    else:
                        timeout=30
                    if md5==self.util.md5(cmd+str(self.salt)):

                        # self.keys.append(key)
                        self.delete_cmd(host,key)
                        def tmp():
                            print('cmd:',cmd)
                            result = ZbxCommand(cmd,is_log=True).run(float(timeout))
                            try:
                                result=result.decode('utf-8')
                            except Exception as utfer:
                                try:
                                    result=result.decode('gbk')
                                except Exception as gbker:
                                    try:
                                        result=result.decode('utf-8','ignore')
                                    except Exception as ler:
                                        pass
                            message = {'ip':ip, 'cmd':cmd, 'result':result,'index':createdIndex,'task_id':cmd_uuid}
                            # print(message)
                            # print(type(message))
                            self.remote_server('cli','feedback_result',message)
                            # print(json.dumps(message))
                        threading.Thread(target=tmp).start()
                    else:
                        print('salt error',self.salt)
                        logger.error('miss command %s ' %(cmd))
                        self.delete_cmd(host,key)
                        message = {'ip':ip, 'cmd':cmd, 'result':'valid salt','index':createdIndex}
                        self.remote_server('cli','feedback_result',message)

            except BaseException as e:
                try:
                    self.delete_cmd(host,key)
                    logger.error('lost command : '+str(data))
                except Exception as er:
                    pass
                logger.error('feedback_result error:'+str(e))
                print(e)


    def feedback_result2(self,ip,host,content):
        try:
            # logger.info("process cmd")
            if content == "Not Found":
                print("no found key")
                return
            rjson = json.loads(content)
            if not rjson['node'].get('dir',False):
                url = "%s/%s?recursive=true" % (host,rjson['node']['key'])
                print("feedback_result"+ url)
                self.util.url_fetch(url,httpCmd= 'DELETE' )
                logger.info("publish is no dir")
                return

            if not rjson['node'].get('nodes'):
                # logger.info("no found command")
                return

            logger.info("process cmd")
            key=''
            for cNode in  rjson['node']['nodes']:
                key = cNode['key']
                createdIndex = cNode['createdIndex']
                try:
                    cNode=json.loads(cNode['value'])
                except Exception as er:
                    logger.error('json error lost command : '+str(cNode))
                    self.delete_cmd(host,key)
                    print('json error lost command : '+str(er))
                    continue
                cmd=cNode['cmd']
                if PY2:
                    cmd = cmd.encode('utf-8')
                md5 = str(cNode['md5'])
                if 'timeout' in cNode.keys():
                    timeout = float(cNode['timeout'])
                else:
                    timeout=30
                if md5==self.util.md5(cmd+str(self.salt)):

                    # self.keys.append(key)
                    self.delete_cmd(host,key)
                    def tmp():
                        print('cmd:',cmd)
                        result = ZbxCommand(cmd,is_log=True).run(float(timeout))
                        try:
                            result=result.decode('utf-8')
                        except Exception as utfer:
                            try:
                                result=result.decode('gbk')
                            except Exception as gbker:
                                try:
                                    result=result.decode('utf-8','ignore')
                                except Exception as ler:
                                    pass
                        message = {'ip':ip, 'cmd':cmd, 'result':result,'index':createdIndex}
                        # print(message)
                        # print(type(message))
                        self.remote_server('cli','feedback_result',message)
                        # print(json.dumps(message))
                    threading.Thread(target=tmp).start()
                else:
                    print('salt error',self.salt)
                    logger.error('miss command %s ' %(cmd))
                    self.delete_cmd(host,key)
                    message = {'ip':ip, 'cmd':cmd, 'result':'valid salt','index':createdIndex}
                    self.remote_server('cli','feedback_result',message)

        except BaseException as e:
            try:
                self.delete_cmd(host,key)
                logger.error('lost command : '+str(cNode))
            except Exception as er:
                pass
            logger.error('feedback_result error:'+str(e))
            print(e)



    def sync_conf(self):
        try:
            self.heartbeat2server()
        except Exception as er:
            pass
        while True:
            try:
                # self.get_etcd()
                self.heartbeat2server()
                time.sleep(2)
                self.heartbeat()
                if not global_debug:
                    time.sleep(60*2+ random.randint(1,60*2))
                else:
                    time.sleep(10)
            except Exception as er:
                logger.error('sync_conf error:'+str(er))
                pass

    def run(self):
        self.update_time=time.time()-800
        self.has_heartbeat_error=False
        sync=threading.Thread(target=self.sync_conf)
        sync.setDaemon(True)
        sync.start()

        time.sleep(3)

        while True:
            try:
                # self.get_etcd()
                # self.heartbeat()
                self.watch_commmand()
                time.sleep(0.5)
            except BaseException as e:
                pass
                time.sleep(5)


if __name__ == '__main__':
    if os.path.isfile(configfile):
        with open(configfile) as f:
            try:
                for l in f.read().strip().split("\n"):
                    k,v=l.split('=',1)
                    if k.strip()=='server_url' and v!='':
                        server_url=v.strip()
                    if k.strip()=='pidfile' and v!='':
                        pidfile=v.strip()
            except Exception as er:
                logger.error(er)
                pass

    server=os.environ.get('CLI_SERVER',server_url)
    default_module=os.environ.get('CLI_MODULE',default_module)

    parts=urlparse(server)
    server_url=parts.scheme+'://'+parts.netloc
    if parts.path.strip()!='':
        default_module= parts.path[1:]

    global_debug=os.environ.get('CLI_DEBUG',global_debug)
    module=default_module
    action='help'
    cli=ZbxCli(default_module)
    util=ZbxCommon()
    data= util.getopt(sys.argv[1:])

    if data['__ctrl__']=='':
        if data['__func__']=='':
            action='help'
        else:
            action=data['__func__']
    else:
        module=data['__ctrl__']
        action=data['__func__']
    if hasattr(cli,action):
       getattr(cli,action)(sys.argv[2:])
    else:
       cli.default(module,action,sys.argv[1:])
