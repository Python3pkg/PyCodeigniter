#!/usr/bin/python
# -*- coding:utf8 -*-
__author__ = 'xiaozhang'


import shutil,subprocess,time,traceback
import   atexit
from signal import SIGTERM

import os
import urllib2
import urllib
import subprocess
import time
import datetime
import re
import logging
import sys
import json
import tempfile
import threading
import getopt
from logging.handlers import RotatingFileHandler
import json


pidfile="/var/zbxcli.pid"
server_url="http://172.17.140.116:8005"

default_module='cli'

bin_name='client'
client_filename='/bin/%s' % bin_name
client_log_filename= tempfile.gettempdir()+os.path.sep+ bin_name+".log"
script_path= tempfile.gettempdir()+ os.path.sep+'script'


logger = logging.getLogger()
logging.basicConfig(level=logging.DEBUG,
                format='%(asctime)-25s %(module)s:%(lineno)d  %(levelname)-8s %(message)s',
                #datefmt='%a, %d %b %Y %H:%M:%S',
                filename=tempfile.gettempdir()+ os.path.sep +'zbxcli.log',
                filemode='a')
logger.addHandler(RotatingFileHandler(filename=client_log_filename,maxBytes=100 * 1024 * 1024, backupCount=3))

class Daemon(object):
        """
        A generic daemon class.

        Usage: subclass the Daemon class and override the run() method
        """
        def __init__(self, pidfile, stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
                self.stdin = stdin
                self.stdout = stdout
                self.stderr = stderr
                self.pidfile = pidfile

        def daemonize(self):
                """
                do the UNIX double-fork magic, see Stevens' "Advanced
                Programming in the UNIX Environment" for details (ISBN 0201563177)
                http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
                """
                try:
                        pid = os.fork()
                        if pid > 0:
                                # exit first parent
                                sys.exit(0)
                except OSError, e:
                        sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
                        sys.exit(1)

                # decouple from parent environment
                os.chdir("/")
                os.setsid()
                os.umask(0)

                # do second fork
                try:
                        pid = os.fork()
                        if pid > 0:
                                # exit from second parent
                                sys.exit(0)
                except OSError, e:
                        sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
                        sys.exit(1)

                # redirect standard file descriptors
                sys.stdout.flush()
                sys.stderr.flush()
                si = file(self.stdin, 'r')
                so = file(self.stdout, 'a+')
                se = file(self.stderr, 'a+', 0)
                os.dup2(si.fileno(), sys.stdin.fileno())
                os.dup2(so.fileno(), sys.stdout.fileno())
                os.dup2(se.fileno(), sys.stderr.fileno())

                # write pidfile
                atexit.register(self.delpid)
                pid = str(os.getpid())
                file(self.pidfile,'w+').write("%s\n" % pid)

        def delpid(self):
                os.remove(self.pidfile)

        def start(self):
                """
                Start the daemon
                """
                # Check for a pidfile to see if the daemon already runs
                try:
                        pf = file(self.pidfile,'r')
                        pid = int(pf.read().strip())
                        pf.close()
                except IOError:
                        pid = None
                if pid:
                        message = "pidfile %s already exist. Daemon already running?\n"
                        sys.stderr.write(message % self.pidfile)
                        sys.exit(1)

                # Start the daemon
                self.daemonize()
                self.run()

        def stop(self):
                """
                Stop the daemon
                """
                # Get the pid from the pidfile
                try:
                        pf = file(self.pidfile,'r')
                        pid = int(pf.read().strip())
                        pf.close()
                except IOError:
                        pid = None

                if not pid:
                        message = "pidfile %s does not exist. Daemon not running?\n"
                        sys.stderr.write(message % self.pidfile)
                        return # not an error in a restart

                # Try killing the daemon process
                try:
                        while 1:
                                os.kill(pid, SIGTERM)
                                time.sleep(0.1)
                except OSError, err:
                        err = str(err)
                        if err.find("No such process") > 0:
                                if os.path.exists(self.pidfile):
                                        os.remove(self.pidfile)
                        else:
                                print str(err)
                                sys.exit(1)

        def restart(self):
                """
                Restart the daemon
                """
                self.stop()
                self.start()


class ZbxCommand(object):
    def __init__(self, cmd):
        self.cmd = cmd
        self.process = None
        self.uuid=str(datetime.datetime.now()).replace(' ','').replace(':','').replace('-','').replace('.','')
        self.result=open(tempfile.gettempdir()+ os.path.sep +self.uuid,'a+')

    def run(self, timeout=30):
        def target():
            logger.info(self.cmd)
            self.process = subprocess.Popen(self.cmd, shell=True,stdout=self.result,stderr=self.result)
            self.process.communicate()
        thread = threading.Thread(target=target)
        thread.start()
        thread.join(timeout)
        if thread.is_alive():
            logger.info(self.cmd)
            #print 'Terminating process'
            self.process.terminate()
            thread.join()
            util=ZbxCommon()
            util.url_fetch(server_url+'/slowlog',{'param':{ 'cmd':self.cmd,'ip':util.get_one_ip()}})
            return "13800138000"
        result= open(tempfile.gettempdir()+ os.path.sep+self.uuid,'r').read()
        os.unlink(tempfile.gettempdir()+ os.path.sep+self.uuid)
        return result


class ZbxCommon(object):
    def urlencode(self,str):
        reprStr=repr(str).replace(r'\x','%')
        return reprStr[1:-1]

    def download(self,filename,directory,filepath):
        try:
            data={'file':filename,'dir':directory}
            data=urllib.urlencode(data)
            http_url='%s/download?%s' % (server_url,data)
            conn = urllib2.urlopen(http_url)
            f = open(filepath,'wb')
            f.write(conn.read())
            f.close()
        except Exception as e:
            logger.error(e)
            print e

    def upload(self,url,filepath,directory):
        boundary = '----------%s' % hex(int(time.time() * 1000))
        data = []
        data.append('--%s' % boundary)
        fr=open(filepath,'rb')
        filename=os.path.basename(filepath)
        data.append('Content-Disposition: form-data; name="%s"\r\n' % 'filename')
        data.append(filename)
        data.append('--%s' % boundary)
        data.append('Content-Disposition: form-data; name="%s"\r\n' % 'dir')
        data.append(directory)
        data.append('--%s' % boundary)
        data.append('Content-Disposition: form-data; name="%s"; filename="%s"' % ('file',filename))
        data.append('Content-Type: %s\r\n' % 'image/png')
        data.append(fr.read())
        fr.close()
        data.append('--%s--\r\n' % boundary)

        http_body='\r\n'.join(data)
        try:
            req=urllib2.Request(url, data=http_body)
            req.add_header('Content-Type', 'multipart/form-data; boundary=%s' % boundary)
            req.add_header('User-Agent','Mozilla/5.0')
            req.add_header('Referer','http://remotserver.com/')
            resp = urllib2.urlopen(req, timeout=5)
            qrcont=resp.read()
            print qrcont
        except Exception as e:
            logger.error(e)
            print e
            print 'http error'

    def url_fetch(self,url,data=None,timeout=30,httpCmd=''):
        html='';
        # print(url)
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        key=''
        if os.path.isfile(fn):
            with open(fn) as f:
                key=f.read().strip()
        try:
            headers = {
                'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6',
                'auth-uuid':key
            }
            if data!=None:
                data=urllib.urlencode(data)
            req = urllib2.Request(
                url =url,
                headers = headers,
                data=data
            )
            if httpCmd <> "":
                req.get_method = lambda: httpCmd

            html=urllib2.urlopen(req,timeout=timeout).read()
            charset=re.compile(r'<meta[^>]*charset=[\'\"]*?([a-z0-8\-]+)[\'\"]?[^>]*?>',re.IGNORECASE).findall(html)
            if len(charset) >0:
                if charset[0]=='gb2312':
                    charset[0]='gbk'
                html=unicode(html,charset[0])
            #print(html)
        except Exception as e:
            if hasattr(e,'msg'):
                print(e.msg)
            else:
                print e

            logger.error(e)
        return html
    def getopt(self,inputs):
        def ptype(input):
            if "-" == input[0] and len(input) == 2:
                return (1,input[1])
            if "--" == input[:2] and len(input) >= 4:
                return (2,input[2:])
            return (0,"")
        def istype(input):
            if "-" == input[0]:
                return 1
            return 0
        ret = {}
        ret['__ctrl__']=''
        ret['__func__']=''
        u = 0
        ucount = len(inputs)
        icount = 0
        ls = []
        if ucount >= 1:
            while 1:
                if u >= ucount:
                    break
                if istype(inputs[u]) == 1:
                    break

                ls.append(inputs[u])
                u += 1

            inputs = inputs[u:]
            icount = len(inputs)

        if icount >= 1:
            i = 0
            state = 0
            while 1:
                t,name = ptype(inputs[i])
                for c in range(1):
                    if t == 0 :
                        i += 1
                        break
                    if i+1 < icount:
                        tt,tname = ptype(inputs[i+1])
                        if tt <> 0:
                            ret[name] = ""
                            i += 1
                            break
                        ret[name] = inputs[i+1]
                        i += 2
                        break
                    ret[name] = ""
                    i += 1
                    break
                if i >= icount:
                    break
        if len(ls)==2:
            ret['__ctrl__']=ls[0]
            ret['__func__']=ls[1]
        elif len(ls)==1:
            ret['__ctrl__']=''
            ret['__func__']=ls[0]
        return (ret)

    def parse_argv(self,argv):
        data={}
        long_args=[]
        short_args=[]
        for v in argv:
            if v.startswith('--'):
                long_args.append(v.replace('--','')+"=")
            elif v.startswith('-'):
                short_args.append(v.replace('-',''))
        opts= getopt.getopt(argv,":".join(short_args)+":",long_args)
        for opt in opts[0]:
            data[opt[0].replace('-','')]=opt[1]
        if len(data)>0:
            return data
        else:
            return argv



    def now_datetime(self):
        now_datetime = time.strftime('_%Y-%m-%d_%H_%M_%S', time.localtime(time.time()))
        return now_datetime

    def backup_config(self,src):
        ret = 1
        if not os.path.exists(src):
            print 'not exist {0}'.format(src)
            logging.error("not exists {0}".format(src))
            sys.exit(-1)

        dst = ''.join([src, self.now_datetime()])
        if not os.path.exists(dst):
            ret = os.system('cp -af {0} {1}'.format(src, dst))
            if not ret:
                logging.info("cp -af {0} {1}".format(src, dst))
            else:
                print "cp error"
                logging.error("ret={0} cp {2} {2}".format(ret, src, dst))
                sys.exit(-2)
        else:
            print 'exist dst'
            logging.error("exist {0}".format(dst))
            sys.exit(-3)

        return ret

    def execute(self,cmd):
        try:
            return os.popen(cmd).read()
        except Exception as err:
            logger.error(err)
            return ""


    def get_all_ip_list(self):
        cmdline = "ip a | egrep \"^\s*inet.*\" | grep -v inet6 | awk '{print $2}' | awk -v FS='/' '{print $1}'"
        ret = self.execute(cmdline)
        lip=re.split(r'\n',ret)
        ips=[]
        for ip in lip:
            if str(ip).strip ()!='':
              ips.append(ip.strip())
        return ips


    def get_one_ip(self):
        #ret = [x for x in self.get_all_ip_list() if x.startswith('10') or x.startswith('172') or x.startswith('192')]
        ret = [x for x in self.get_all_ip_list() if x.startswith('10.') ]
        if len(ret)>1:
            return ret[0]
        return ''.join(ret)

    def get_hostname(self):
        os_name = os.name
        host_name = None
        if os_name == 'nt':
            host_name = os.getenv('computername')
        elif os_name == 'posix':
            host = os.popen('hostname')
            try:
                host_name = host.read().strip()
            finally:
                host.close()
        return host_name


    def exec_filename(self):
        import os, sys, inspect
        path = os.path.realpath(sys.path[0])
        if os.path.isfile(path):
            path = os.path.dirname(path)
            return os.path.abspath(path)+ os.path.sep+__file__
        else:
            caller_file = inspect.stack()[1][1]
            return os.path.abspath(os.path.dirname(caller_file))+ os.path.sep+__file__


    def backup_config(self,src):
        """

        :return:
        """
        ret = 1
        if not os.path.exists(src):
            print 'not exist {0}'.format(src)
            logging.error("not exists {0}".format(src))
            sys.exit(-1)

        dst = ''.join([src, self.now_datetime()])
        if not os.path.exists(dst):
            ret = os.system('cp -af {0} {1}'.format(src, dst))
            if not ret:
                logging.info("cp -af {0} {1}".format(src, dst))
            else:
                print "cp error"
                logging.error("ret={0} cp {2} {2}".format(ret, src, dst))
                sys.exit(-2)
        else:
            print 'exist dst'
            logging.error("exist {0}".format(dst))
            sys.exit(-3)

        return ret

    def update_config(self,src):
        """

        :return:
        """
        dst = '/data/zabbix/conf/zabbix_agentd.conf'
        ret = os.system('echo "{0}" > {1}'.format(src, dst))
        if not ret:
            logging.info("update {0}".format(dst))
        else:
            print "cp error"
            logging.error("ret={0} update {1} {2}".format(ret, src, dst))
            sys.exit(-2)

    def tuple2list(self,*args):
        print(args)
        l=[]
        for i in args:
            l.append(i)
        return l

    def command_args(self,args):
        if isinstance(args,list) or isinstance(args,tuple):
            return '"%s"' % '" "'.join(args)
        else:
            return str(args)





class ZbxCli():


    def __init__(self,default_module):
        self.entry=server_url+'/'+default_module+"/%s"
        self.util=ZbxCommon()


    def download(self,args):
        argv= self.util.parse_argv(args)
	if isinstance(argv,list):
            argv={}
        if 'f' in argv.keys():
            f=argv['f']
        else:
            return '(error) -f(filename) require'
        if 'd' not in argv:
            argv['d']='/'
        if 'o' not in argv:
            argv['o']=argv['f']
        self.util.download(argv['f'],argv['d'],argv['o'])

    def upload(self,args):
        argv= self.util.parse_argv(args)
	if isinstance(argv,list):
            argv={}
        if 'f' in argv.keys():
            f=argv['f']
        else:
            return '(error) -f(filename) require'
        if 'd' not in argv:
            argv['d']='/'
        self.util.upload(self.entry%"upload", argv['f'],argv['d'])

    def help(self,args):
        ret=self.util.url_fetch(self.entry%'help')
        print ret

    def upgrade(self,args):
        fn=self.util.exec_filename()
        content=self.util.url_fetch(self.entry%'upgrade')
        if content!='':
            open('/tmp/cli','w').write(content)
            os.system('chmod +x /tmp/cli')
            os.system('mv -f /tmp/cli %s' %(client_filename))
            print 'success'
        else:
            print 'fail'
    def adddoc(self,args):
        argv=self.util.getopt(args)
        if 'f' in argv:
            argv['d']=open(argv['f'],'r').read()

        ret=self.util.url_fetch(self.entry%'adddoc',{'param':json.dumps(argv)})
        print ret

    def daemon(self,argv):
        daemon = ZbxDaemon(pidfile)
        setattr(daemon,'zbxcli',self)
        data= self.util.getopt(sys.argv[1:])
        opt = data.get('s')
        if 'start' == opt:
            print "cli daemon start"
            daemon.start()
        elif 'stop' == opt:
            print "cli daemon stop"
            daemon.stop()
        elif 'restart' == opt:
            print "cli daemon restart"
            daemon.restart()
        else:
            print "usage: cli deamon -s start|stop|restart"
            sys.exit(2)
        sys.exit(0)

    def logout(self,argv):
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        if os.path.isfile(fn):
            with open(fn,"w") as f:
                f.write('')

    def login(self,argv):
        data= self.util.getopt(sys.argv[1:])
        if 'u' not in data:
            data['u']=raw_input('please input username: ')
        if 'p' not in data:
            import getpass
            data['p']=getpass.getpass('please input password: ')
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(data)})
        home= os.path.expanduser('~')
        fn=home+'/.cli'
        if os.path.isfile(fn):
            with open(fn,"w") as f:
                f.write(ret)
                if len(ret)==36:
                    print 'success'
                    return
                else:
                    print 'fail'
                    return
        print 'fail'


    def default(self,module,action,args):
        #argv= self.util.parse_argv(args)
        argv=self.util.getopt(args)
        if isinstance(argv,list):
            argv={}
        if isinstance(argv,dict):
            if not 's' in argv:
                argv['s']=self.util.get_hostname()
            if not 'i' in argv:
                argv['i']=self.util.get_one_ip()
            #if not 'g' in argv:
            #    argv['g']="Discovered hosts"
            #if not 't' in argv:
            #    argv['t']="Meizu-System"
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(argv)})
        print(ret)
        return ret

    def remote_server(self,module,action,argv):
        if isinstance(argv,dict):
            if not 's' in argv:
                argv['s']=self.util.get_hostname()
            if not 'i' in argv:
                argv['i']=self.util.get_one_ip()
            #if not 'g' in argv:
            #    argv['g']="Discovered hosts"
            #if not 't' in argv:
            #    argv['t']="Meizu-System"
        ret=self.util.url_fetch(server_url+'/%s/%s'%(module,action),{'param':json.dumps(argv)})
        return ret

    def shell(self,args):
        if len(args)<1:
            print('ERROR: param is not enough')
            sys.exit(0)

        #path=tempfile.gettempdir()+os.sep+'zbxcli';
        filename=''
        argv= self.util.parse_argv(args)
        if 'f' in argv.keys():
            filename=argv['f']
        else:
            return '(error) -f(filename) require'
        path=script_path
        if not os.path.exists(path):
            self.util.execute('mkdir -p %s'%path)

        fn=path+os.path.sep+filename
        src=''
        is_python=False
        result=-1
        if not os.path.exists(fn) or os.stat(fn).st_mtime<(time.time()-10*60):
            src=self.util.url_fetch(self.entry%'shell',{ 'file':filename, 'param': json.dumps(args[1:])},timeout=60*60)
        if src!='':
            open(fn,'w').write(src)
        else:
            src=open(fn,'r').read()

        lines=re.split(r'\n',src)
        for line in lines:
            if line.strip()!='':
                break;
        if line.find('python')>0:
                is_python=True
        if is_python:
            cmd=ZbxCommand('/usr/bin/python %s %s'% (fn,self.util.command_args(args[1:])))
            result=cmd.run(60*60*24)
        else:
            cmd=ZbxCommand('/bin/bash %s %s'% (fn,self.util.command_args(args[1:])))
            result=cmd.run(60*60*24)
        print(result)

class ZbxDaemon(Daemon):

    def __getattr__(self,attr):
        if hasattr(self,'zbxcli'):
            if hasattr(self.zbxcli,attr):
                return getattr(self.zbxcli,attr)
        return None

    def get_etcd(self):
        now = time.time()
        if not self.update_time:
            self.update_time = now -600
        if now - self.update_time > 600:
            print "=== get etcd"
            self.update_time = now
            self.etcd_list =  json.loads(self.remote_server('cli','getetcd',{}) )
            print "remote",self.etcd_list

    def heartbeat(self):
        print "=== heartbeat start"
        ip = self.util.get_one_ip()
        for host in self.etcd_list:
            html = self.util.url_fetch("http://%s/v2/keys/heartbeat/%s" % (host,ip) ,data={'ttl':60,'value':'2333'},httpCmd = 'PUT' )
            if html != "":
                break
        print "=== heartbeata end"

    def watch_commmand(self):

        ip = self.util.get_one_ip()
        print "watch_commmand",ip,self.etcd_list
        for host in self.etcd_list:
            self.util.url_fetch("http://%s/v2/keys/publish/%s?wait=true&recursive=true" % (host,ip),timeout = 10 )
            content = self.util.url_fetch("http://%s/v2/keys/publish/%s?recursive=true" % (host,ip),timeout = 10 )
            if content != "":
                self.feedback_result(ip,host,content)
                break


    def feedback_result(self,ip,host,content):
        try:
            print "process cmd"
            if content == "Not Found":
                print "no funud key"
                return
            rjson = json.loads(content)
            print rjson
            if not rjson['node'].get('dir',False):
                url = "http://%s/v2/keys%s?recursive=true" % (host,rjson['node']['key'])
                self.util.url_fetch(url,httpCmd= 'DELETE' )
                print "publish is no dir"

                return

            if not rjson['node'].get('nodes'):
                print "no Check command"
                return

            for cNode in  rjson['node']['nodes']:
                cmd = cNode['value'].decode("utf-8")
                key = cNode['key']
                result = ZbxCommand(cmd).run()
                url = "http://%s/v2/keys%s?recursive=true" % (host,key)
                self.util.url_fetch(url,httpCmd= 'DELETE' )
                message = "ip:%s cmd:%s result:%s" % (ip,cmd,result)
                self.remote_server('cli','feedback_result',{'param':message})
                #print "cmd %s result %s" % (cmd,result)

        except BaseException as e:
            print "feed error"
            print e




    def run(self):
        self.get_etcd()
        while True:
            self.get_etcd()
            self.heartbeat()
            self.watch_commmand()
            time.sleep(1)


if __name__ == '__main__':
    module=default_module
    action='help'
    cli=ZbxCli(default_module)
    util=ZbxCommon()
    data= util.getopt(sys.argv[1:])
    if data['__ctrl__']=='':
        if data['__func__']=='':
            action='help'
        else:
            action=data['__func__']
    else:
        module=data['__ctrl__']
        action=data['__func__']
    if hasattr(cli,action):
       getattr(cli,action)(sys.argv[2:])
    else:
       cli.default(module,action,sys.argv[1:])

    #if len(sys.argv)<2:
    #    cli.help(sys.argv)
    #    sys.exit(0)
    #elif (len(sys.argv)==2) or (len(sys.argv)>2 and sys.argv[2].startswith('-')):
    #    action=sys.argv[1]
    #elif len(sys.argv)>2 and not sys.argv[2].startswith('-'):
    #    module=sys.argv[1]
    #    action=sys.argv[2]
    #elif len(sys.argv)>2 :
    #    module=sys.argv[1]
    #    action=sys.argv[2]
    #if hasattr(cli,action):
    #   getattr(cli,action)(sys.argv[2:])
    #else:
    #   cli.default(module,action,sys.argv[2:])







